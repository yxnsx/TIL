# :fire: Hilt
* 종속성 주입을 위해 사용하는 `Android Jetpack`의 라이브러리
* 프로젝트의 모든 Android 클래스에 컨테이너를 제공하고 자동으로 수명주기를 관리한다.
<br>

### :sparkles: Hilt 사용의 장점
* DI 라이브러리인 `Dagger`를 기반으로 빌드되어, `Dagger`가 제공하는 컴파일 시간 정확성, 런타임 성능, 확장성 및 `Android Studio` 지원의 이점을 누릴 수 있다.
* DI 구현의 장점
  * 코드의 재사용 용이
  * 리팩토링 용이
  * 테스트 용이
<br>

### :sparkles: Hilt 사용을 위한 환경 구축
#### :one: 프로젝트의 루트 `build.gradle` 파일에 `hilt-android-gradle-plugin` 추가
```xml
buildscript {
    ...
    ext.hilt_version = '2.33-beta'
    dependencies {
        ...
        classpath "com.google.dagger:hilt-android-gradle-plugin:$hilt_version"
    }
}
```
<br>

#### :two: `app/build.gradle` 파일에 `apply plugin`과 `dependencies` 추가
* `Hilt`와 `DataBinding`을 모두 사용하는 프로젝트의 경우, Android Studio 버전이 4.0 이상이어야 한다.
```xml
...
apply plugin: 'kotlin-kapt'
apply plugin: 'dagger.hilt.android.plugin'

android {
    ...
}

dependencies {
    implementation "com.google.dagger:hilt-android:$hilt_version"
    kapt "com.google.dagger:hilt-compiler:$hilt_version"
}
```
<br>

#### :three: `app/build.gradle`에 Java 8 `compileOptions` 추가
```xml
android {
    ...
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
```
<br>

### :sparkles: Hilt 구현 방법
#### :heavy_check_mark: Hilt 애플리케이션 클래스 생성
* `Hilt`를 사용하는 모든 앱에는 `@HiltAndroidApp` 주석이 달린 `Application` 클래스가 존재해야 한다.
* `@HiltAndroidApp` 은 애플리케이션 레벨의 종속성 컨테이너를 제공하는 베이스 클래스를 포함하는 `Hilt`의 코드를 생성한다.
```kotlin
@HiltAndroidApp
class ExampleApplication : Application() { … }
```
<br>

#### :heavy_check_mark: Android 클래스에 종속성 삽입
* `Hilt`가 Application 클래스에 설정되고 애플리케이션 레벨의 구성요소를 사용할 수 있게 되면, `Hilt`는 `@AndroidEntryPoint` 주석이 있는 다른 Android 클래스에 종속성을 제공할 수 있다.
* `Hilt`가 지원하는 Android 클래스
  * Application (`@HiltAndroidApp` 사용)
  * ViewModel (`@HiltViewModel` 사용)
  * Activity
  * Fragment
  * View
  * Service
  * BroadcastReceiver
```kotlin
@AndroidEntryPoint
class ExampleActivity : AppCompatActivity() { ... }
```

* `@AndroidEntryPoint`를 이용하여 Android 클래스에 주석을 달아주었다면, 해당 클래스에 종속된 Android 클래스에도 주석을 추가해주어야 한다.
* `@AndroidEntryPoint`는 프로젝트의 Android 클래스에 대해 개별적인 `Hilt` 컴포넌트를 생성한다.
* 이러한 `Hilt` 컴포넌트는 상위 클래스로부터 종속성 주입을 받을 수 있다.
* 컴포넌트로부터 종속성을 얻으려면 필드 주입을 위한 `@Inject`를 사용해야 한다.
  * `Hilt`에 의해 주입된 필드는 `private`일 수 없다. 
  * `Hilt`를 통해 `private` 필드를 주입한 경우, 컴파일 에러가 발생한다.
```kotlin
@AndroidEntryPoint
class ExampleActivity : AppCompatActivity() {

    @Inject lateinit var analytics: AnalyticsAdapter
    ...
}
```

* `Hilt`가 주입한 클래스는 주입을 사용한 다른 베이스 클래스를 지닐 수 있다.
* 이러한 클래스들이 추상 클래스일 경우, `@AndroidEntryPoint` 주석이 필요하지 않다.
<br>

#### :heavy_check_mark: Hilt binding 정의
* 필드 주입을 수행하기 위해서는 `Hilt`가 해당 컴포넌트에서 필요한 종속성의 인스턴스를 제공하는 방법을 알아야 한다.
* binding은 종속 타입의 인스턴스를 제공하는데에 필수적인 정보를 포함한다.
* `Hilt`에 바인딩 정보를 제공하기 위해서 constructor injection을 사용한다.
* 클래스의 생성자에서 `@Inject` 주석을 사용하여 해당 클래스에 인스턴스를 제공하는 방법을 `Hilt`에 알린다.
```kotlin
class AnalyticsAdapter @Inject constructor(
    private val service: AnalyticsService
) { ... }
```

* `@Inject` 주석으로 처리된 생성자의 파라미터들은 해당 클래스의 종속성이다.
* `AnalyticsAdapter`는 `AnalyticsService`를 종속성으로 지니므로, `Hilt`는 `AnalyticsService`의 인스턴스를 어떻게 제공하는지에 대한 방법을 반드시 알고있어야 한다.
<br>

#### :heavy_check_mark: Hilt modules
* 인터페이스, 외부 라이브러리의 클래스 등 특정 타입은 constructor injection이 불가능 할 수 있다.
* 이러한 경우, `Hilt module`을 이용하여 바인딩 정보를 `Hilt`에 제공할 수 있다.
* `Hilt module`은 `@Module` 주석이 있는 클래스이며, `Hilt`에 특정 타입의 인스턴스를 제공하는 방법을 알린다.
* `Dagger module`과는 달리 `Hilt module`에는 각 모듈이 사용되거나 설치될 Android 클래스를 `Hilt`에 알리는 `@InstallIn` 주석을 반드시 추가해야 한다.
* `Hilt module`에서 제공하는 종속성은 `Hilt module`을 설치하는 Android 클래스와 연결된 모든 생성된 컴포넌트에서 사용할 수 있다.
* `Hilt`의 코드 생성은 `Hilt`를 사용하는 모든 `Gradle module`에 접근해야 하므로, Application 클래스를 컴파일하는 `Gradle module` 역시 모든 `Hilt module`과 constructor-injected 클래스를 지니고 있어야 한다.
<br>

* `@Binds`를 사용하여 인터페이스 인스턴스 주입
  * constructor injection이 불가능할 경우, `Hilt module` 내의 `@Binds` 주석을 이용하여 추상 함수를 만들어서 바인딩 객체와 함께 Hilt를 제공할 수 있다.
  * `@Bind` 주석은 `Hilt`가 인터페이스의 인스턴스를 필요로 할 때 어떤 implementation을 사용해야할지 알려준다.
  * `@Bind` 주석처리된 함수는 두 가지의 정보를 `Hilt`에 알려준다
    * 함수의 리턴타입은 함수가 인스턴스를 제공하는 인터페이스를  `Hilt`에 알려준다.
    * 함수의 파라미터는 어떤 implementation을 제공해야할지 `Hilt`에 알려준다.
  * `Hilt module`인 `AnalyticsModule`은 `Hilt`가 `ExampleActivity`로 종속성을 주입하도록 하기 위해 `@InstallIn(ActivityComponent::class)` 주석으로 처리 되었다.
  * 이 주석은 `AnalyticsModule`의 모든 종속성을 앱의 모든 액티비티에서 사용할 수 있음을 의미한다.
```kotlin
interface AnalyticsService {
  fun analyticsMethods()
}

// Constructor-injected, because Hilt needs to know how to
// provide instances of AnalyticsServiceImpl, too.
class AnalyticsServiceImpl @Inject constructor(
  ...
) : AnalyticsService { ... }

@Module
@InstallIn(ActivityComponent::class)
abstract class AnalyticsModule {

  @Binds
  abstract fun bindAnalyticsService(
    analyticsServiceImpl: AnalyticsServiceImpl
  ): AnalyticsService
}
```
<br>

### :memo: Reference
* https://developer.android.com/training/dependency-injection
